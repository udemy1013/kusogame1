//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Scripting;
using Unity.Services.Leaderboards.Authoring.Client.Models;
using Unity.Services.Leaderboards.Authoring.Client.Scheduler;
using Unity.Services.Leaderboards.Authoring.Client.Http;


namespace Unity.Services.Leaderboards.Authoring.Client.Default
{
    internal static class JsonSerialization
    {
        public static byte[] Serialize<T>(T obj)
        {
            return Encoding.UTF8.GetBytes(SerializeToString(obj));
        }

        public static string SerializeToString<T>(T obj)
        {
            return IsolatedJsonConvert.SerializeObject(obj, new JsonSerializerSettings{ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore});
        }
    }

    /// <summary>
    /// DefaultApiBaseRequest class
    /// </summary>
    [Preserve]
    internal class DefaultApiBaseRequest
    {
        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>` with the `key` and `value` added to the provided `queryParams`.</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, string value)
        {
            key = UnityWebRequest.EscapeURL(key);
            value = UnityWebRequest.EscapeURL(value);
            queryParams.Add($"{key}={value}");

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and list of values to the
        /// provided query params and to escape the values correctly if it is a
        /// URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="values">List of values to be added.</param>
        /// <param name="style">string for defining the style, currently unused.</param>
        /// <param name="explode">True if query params should be escaped and added separately.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, List<string> values, string style, bool explode)
        {
            if (explode)
            {
                foreach(var value in values)
                {
                    string escapedValue = UnityWebRequest.EscapeURL(value);
                    queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
                }
            }
            else
            {
                string paramString = $"{UnityWebRequest.EscapeURL(key)}=";
                foreach(var value in values)
                {
                    paramString += UnityWebRequest.EscapeURL(value) + ",";
                }
                paramString = paramString.Remove(paramString.Length - 1);
                queryParams.Add(paramString);
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided map of keys and values, representing a model, to the
        /// provided query params.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="modelVars">A `Dictionary` representing the vars of the model</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, Dictionary<string, string> modelVars)
        {
            foreach(var key in modelVars.Keys)
            {
                string escapedValue = UnityWebRequest.EscapeURL(modelVars[key]);
                queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <typeparam name="T">The type of the value to be added.</typeparam>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams<T>(List<string> queryParams, string key, T value)
        {
            if (queryParams == null)
            {
                queryParams = new List<string>();
            }

            key = UnityWebRequest.EscapeURL(key);
            string valueString = UnityWebRequest.EscapeURL(value.ToString());
            queryParams.Add($"{key}={valueString}");
            return queryParams;
        }

        /// <summary>
        /// Constructs a string representing an array path parameter.
        /// </summary>
        /// <param name="pathParam">The list of values to convert to string.</param>
        /// <returns>String representing the param.</returns>
        [Preserve]
        public string GetPathParamString(List<string> pathParam)
        {
            string paramString = "";
            foreach(var value in pathParam)
            {
                paramString += UnityWebRequest.EscapeURL(value) + ",";
            }
            paramString = paramString.Remove(paramString.Length - 1);
            return paramString;
        }

        /// <summary>
        /// Constructs the body of the request based on IO stream.
        /// </summary>
        /// <param name="stream">The IO stream to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(System.IO.Stream stream)
        {
            if (stream != null)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return null;
        }

        /// <summary>
        /// Construct the request body based on string value.
        /// </summary>
        /// <param name="s">The input body.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(string s)
        {
            return System.Text.Encoding.UTF8.GetBytes(s);
        }

        /// <summary>
        /// Construct request body based on generic object.
        /// </summary>
        /// <param name="o">The object to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(object o)
        {
            return JsonSerialization.Serialize(o);
        }

        /// <summary>
        /// Generate an accept header.
        /// </summary>
        /// <param name="accepts">list of accepts objects.</param>
        /// <returns>The generated accept header.</returns>
        public string GenerateAcceptHeader(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }
            for (int i = 0; i < accepts.Length; ++i)
            {
                if (string.Equals(accepts[i], "application/json", System.StringComparison.OrdinalIgnoreCase))
                {
                    return "application/json";
                }
            }
            return string.Join(", ", accepts);
        }

        private static readonly Regex JsonRegex = new Regex(@"application\/json(;\s)?((charset=utf8|q=[0-1]\.\d)(\s)?)*");

        /// <summary>
        /// Generate Content Type Header.
        /// </summary>
        /// <param name="contentTypes">The content types.</param>
        /// <returns>The Content Type Header.</returns>
        public string GenerateContentTypeHeader(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return null;
            }

            for(int i = 0; i < contentTypes.Length; ++i)
            {
                if (!string.IsNullOrWhiteSpace(contentTypes[i]) && JsonRegex.IsMatch(contentTypes[i]))
                {
                    return contentTypes[i];
                }
            }
            return contentTypes[0];
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The file stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.FileStream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), GetFileName(stream.Name), contentType);
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The IO stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.Stream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), Guid.NewGuid().ToString(), contentType);
        }

        private string GetFileName(string filePath)
        {
            return System.IO.Path.GetFileName(filePath);
        }
    }

    /// <summary>
    /// CreateLeaderboardRequest
    /// Create Leaderboard
    /// </summary>
    [Preserve]
    internal class CreateLeaderboardRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardIdConfig1 </summary>
        [Preserve]
        public Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardIdConfig1 LeaderboardIdConfig1 { get; }
        string PathAndQueryParams;

        /// <summary>
        /// CreateLeaderboard Request Object.
        /// Create Leaderboard
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardIdConfig1">LeaderboardIdConfig1 param</param>
        [Preserve]
        public CreateLeaderboardRequest(System.Guid projectId, System.Guid environmentId, Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardIdConfig1 leaderboardIdConfig1 = default(Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardIdConfig1))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardIdConfig1 = leaderboardIdConfig1;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(LeaderboardIdConfig1 != null)
            {
                return ConstructBody(LeaderboardIdConfig1);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteLeaderboardRequest
    /// Delete Leaderboard
    /// </summary>
    [Preserve]
    internal class DeleteLeaderboardRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteLeaderboard Request Object.
        /// Delete Leaderboard
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        [Preserve]
        public DeleteLeaderboardRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteLeaderboardPlayerScoreRequest
    /// Delete Leaderboard Player Score
    /// </summary>
    [Preserve]
    internal class DeleteLeaderboardPlayerScoreRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteLeaderboardPlayerScore Request Object.
        /// Delete Leaderboard Player Score
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="playerId">ID of the player</param>
        [Preserve]
        public DeleteLeaderboardPlayerScoreRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string playerId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            PlayerId = playerId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/scores/players/{playerId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteLeaderboardPlayerScoreAllLiveLeaderboardsRequest
    /// Delete Leaderboard Player Score from all Live Leaderboards
    /// </summary>
    [Preserve]
    internal class DeleteLeaderboardPlayerScoreAllLiveLeaderboardsRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteLeaderboardPlayerScoreAllLiveLeaderboards Request Object.
        /// Delete Leaderboard Player Score from all Live Leaderboards
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="playerId">ID of the player</param>
        [Preserve]
        public DeleteLeaderboardPlayerScoreAllLiveLeaderboardsRequest(System.Guid projectId, System.Guid environmentId, string playerId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            PlayerId = playerId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/scores/players/{playerId}/purge";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteLeaderboardVersionRequest
    /// Delete Leaderboard Version
    /// </summary>
    [Preserve]
    internal class DeleteLeaderboardVersionRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteLeaderboardVersion Request Object.
        /// Delete Leaderboard Version
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        [Preserve]
        public DeleteLeaderboardVersionRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardBucketScoresRequest
    /// Get Leaderboard Bucket Scores
    /// </summary>
    [Preserve]
    internal class GetLeaderboardBucketScoresRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for bucketId </summary>
        [Preserve]
        public string BucketId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardBucketScores Request Object.
        /// Get Leaderboard Bucket Scores
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="bucketId">ID of the bucket (uuid)</param>
        /// <param name="offset">The number of entries to skip when retrieving the leaderboard bucket scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard bucket scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardBucketScoresRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string bucketId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            BucketId = bucketId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/buckets/{bucketId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardBucketScoresByTierRequest
    /// Get Leaderboard Bucket Scores By Tier
    /// </summary>
    [Preserve]
    internal class GetLeaderboardBucketScoresByTierRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for bucketId </summary>
        [Preserve]
        public string BucketId { get; }
        /// <summary>Accessor for tierId </summary>
        [Preserve]
        public string TierId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardBucketScoresByTier Request Object.
        /// Get Leaderboard Bucket Scores By Tier
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="bucketId">ID of the bucket (uuid)</param>
        /// <param name="tierId">ID of the leaderboard tier</param>
        /// <param name="offset">The number of entries to skip when retrieving the leaderboard bucket scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard bucket scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardBucketScoresByTierRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string bucketId, string tierId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            BucketId = bucketId;

            TierId = tierId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/buckets/{bucketId}/tiers/{tierId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardBucketsRequest
    /// Get Leaderboard Bucket IDs
    /// </summary>
    [Preserve]
    internal class GetLeaderboardBucketsRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardBuckets Request Object.
        /// Get Leaderboard Bucket IDs
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="offset">The number of buckets to skip when retrieving the leaderboard bucket IDs. Defaults to 0</param>
        /// <param name="limit">The maximum number of leaderboard bucket IDs to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardBucketsRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/buckets";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardConfigRequest
    /// Get Leaderboard Config
    /// </summary>
    [Preserve]
    internal class GetLeaderboardConfigRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardConfig Request Object.
        /// Get Leaderboard Config
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        [Preserve]
        public GetLeaderboardConfigRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardConfigsRequest
    /// Get Leaderboard Configs
    /// </summary>
    [Preserve]
    internal class GetLeaderboardConfigsRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for cursor </summary>
        [Preserve]
        public string Cursor { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardConfigs Request Object.
        /// Get Leaderboard Configs
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="cursor">The ID of the leaderboard that listing should start after, i.e. the last leaderboard returned from the previous page when paging</param>
        /// <param name="limit">The number of leaderboards to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardConfigsRequest(System.Guid projectId, System.Guid environmentId, string cursor = default(string), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            Cursor = cursor;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(Cursor))
            {
                queryParams = AddParamsToQueryParams(queryParams, "cursor", Cursor);
            }
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardPlayerRangeRequest
    /// Get Player Range
    /// </summary>
    [Preserve]
    internal class GetLeaderboardPlayerRangeRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for rangeLimit </summary>
        [Preserve]
        public int? RangeLimit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardPlayerRange Request Object.
        /// Get Player Range
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="playerId">ID of the player</param>
        /// <param name="rangeLimit">The number of entries either side of the player to retrieve. Defaults to 5.</param>
        [Preserve]
        public GetLeaderboardPlayerRangeRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string playerId, int? rangeLimit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            PlayerId = playerId;

            RangeLimit = rangeLimit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/scores/players/{playerId}/range";

            List<string> queryParams = new List<string>();

            var rangeLimitStringValue = RangeLimit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "rangeLimit", rangeLimitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardPlayerRangeArchivedVersionRequest
    /// Get Player Range for archived leaderboard version
    /// </summary>
    [Preserve]
    internal class GetLeaderboardPlayerRangeArchivedVersionRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for rangeLimit </summary>
        [Preserve]
        public int? RangeLimit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardPlayerRangeArchivedVersion Request Object.
        /// Get Player Range for archived leaderboard version
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="playerId">ID of the player</param>
        /// <param name="rangeLimit">The number of entries either side of the player to retrieve. Defaults to 5.</param>
        [Preserve]
        public GetLeaderboardPlayerRangeArchivedVersionRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, string playerId, int? rangeLimit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            PlayerId = playerId;

            RangeLimit = rangeLimit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/scores/players/{playerId}/range";

            List<string> queryParams = new List<string>();

            var rangeLimitStringValue = RangeLimit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "rangeLimit", rangeLimitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardPlayerScoreRequest
    /// Get Leaderboard Player Score
    /// </summary>
    [Preserve]
    internal class GetLeaderboardPlayerScoreRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardPlayerScore Request Object.
        /// Get Leaderboard Player Score
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="playerId">ID of the player</param>
        [Preserve]
        public GetLeaderboardPlayerScoreRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string playerId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            PlayerId = playerId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/scores/players/{playerId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardPlayersScoresByPlayerIdsRequest
    /// Get Leaderboard Players Scores by Player Ids
    /// </summary>
    [Preserve]
    internal class GetLeaderboardPlayersScoresByPlayerIdsRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for leaderboardPlayerIds1 </summary>
        [Preserve]
        public Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardPlayerIds1 LeaderboardPlayerIds1 { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardPlayersScoresByPlayerIds Request Object.
        /// Get Leaderboard Players Scores by Player Ids
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="leaderboardPlayerIds1">LeaderboardPlayerIds1 param</param>
        [Preserve]
        public GetLeaderboardPlayersScoresByPlayerIdsRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardPlayerIds1 leaderboardPlayerIds1 = default(Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardPlayerIds1))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            LeaderboardPlayerIds1 = leaderboardPlayerIds1;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/scores/players";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(LeaderboardPlayerIds1 != null)
            {
                return ConstructBody(LeaderboardPlayerIds1);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardPlayersScoresByPlayerIdsArchivedVersionRequest
    /// Get Leaderboard Players Scores by Player Ids for Archived Leaderboard
    /// </summary>
    [Preserve]
    internal class GetLeaderboardPlayersScoresByPlayerIdsArchivedVersionRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for leaderboardPlayerIds1 </summary>
        [Preserve]
        public Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardPlayerIds1 LeaderboardPlayerIds1 { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardPlayersScoresByPlayerIdsArchivedVersion Request Object.
        /// Get Leaderboard Players Scores by Player Ids for Archived Leaderboard
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="leaderboardPlayerIds1">LeaderboardPlayerIds1 param</param>
        [Preserve]
        public GetLeaderboardPlayersScoresByPlayerIdsArchivedVersionRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardPlayerIds1 leaderboardPlayerIds1 = default(Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardPlayerIds1))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            LeaderboardPlayerIds1 = leaderboardPlayerIds1;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/scores/players";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(LeaderboardPlayerIds1 != null)
            {
                return ConstructBody(LeaderboardPlayerIds1);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardScoresRequest
    /// Get Leaderboard Scores
    /// </summary>
    [Preserve]
    internal class GetLeaderboardScoresRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardScores Request Object.
        /// Get Leaderboard Scores
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardScoresRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardScoresByTierRequest
    /// Get Leaderboard Scores By Tier
    /// </summary>
    [Preserve]
    internal class GetLeaderboardScoresByTierRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for tierId </summary>
        [Preserve]
        public string TierId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardScoresByTier Request Object.
        /// Get Leaderboard Scores By Tier
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="tierId">ID of the leaderboard tier</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardScoresByTierRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string tierId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            TierId = tierId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/tiers/{tierId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardVersionBucketScoresRequest
    /// Get Leaderboard Version Bucket Scores
    /// </summary>
    [Preserve]
    internal class GetLeaderboardVersionBucketScoresRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for bucketId </summary>
        [Preserve]
        public string BucketId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardVersionBucketScores Request Object.
        /// Get Leaderboard Version Bucket Scores
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="bucketId">ID of the bucket (uuid)</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard version bucket scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard version bucket scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardVersionBucketScoresRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, string bucketId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            BucketId = bucketId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/buckets/{bucketId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardVersionBucketScoresByTierRequest
    /// Get Leaderboard Version Bucket Scores By Tier
    /// </summary>
    [Preserve]
    internal class GetLeaderboardVersionBucketScoresByTierRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for bucketId </summary>
        [Preserve]
        public string BucketId { get; }
        /// <summary>Accessor for tierId </summary>
        [Preserve]
        public string TierId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardVersionBucketScoresByTier Request Object.
        /// Get Leaderboard Version Bucket Scores By Tier
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="bucketId">ID of the bucket (uuid)</param>
        /// <param name="tierId">ID of the leaderboard tier</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard version bucket scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard version bucket scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardVersionBucketScoresByTierRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, string bucketId, string tierId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            BucketId = bucketId;

            TierId = tierId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/buckets/{bucketId}/tiers/{tierId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardVersionBucketsRequest
    /// Get Leaderboard Version Bucket IDs
    /// </summary>
    [Preserve]
    internal class GetLeaderboardVersionBucketsRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardVersionBuckets Request Object.
        /// Get Leaderboard Version Bucket IDs
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard version bucket IDs. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard version bucket IDs to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardVersionBucketsRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/buckets";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardVersionPlayerScoreRequest
    /// Get Leaderboard Version Player Score
    /// </summary>
    [Preserve]
    internal class GetLeaderboardVersionPlayerScoreRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardVersionPlayerScore Request Object.
        /// Get Leaderboard Version Player Score
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="playerId">ID of the player</param>
        [Preserve]
        public GetLeaderboardVersionPlayerScoreRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, string playerId)
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            PlayerId = playerId;

            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/scores/players/{playerId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardVersionScoresRequest
    /// Get Leaderboard Version Scores
    /// </summary>
    [Preserve]
    internal class GetLeaderboardVersionScoresRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardVersionScores Request Object.
        /// Get Leaderboard Version Scores
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard version scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard version scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardVersionScoresRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetLeaderboardVersionScoresByTierRequest
    /// Get Leaderboard Version Scores By Tier
    /// </summary>
    [Preserve]
    internal class GetLeaderboardVersionScoresByTierRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for versionId </summary>
        [Preserve]
        public string VersionId { get; }
        /// <summary>Accessor for tierId </summary>
        [Preserve]
        public string TierId { get; }
        /// <summary>Accessor for offset </summary>
        [Preserve]
        public int? Offset { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetLeaderboardVersionScoresByTier Request Object.
        /// Get Leaderboard Version Scores By Tier
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="versionId">ID of the leaderboard version</param>
        /// <param name="tierId">ID of the leaderboard tier</param>
        /// <param name="offset">The number of entries to skip when retrieving the Leaderboard version scores. Defaults to 0</param>
        /// <param name="limit">The number of leaderboard version scores to return. Defaults to 10</param>
        [Preserve]
        public GetLeaderboardVersionScoresByTierRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, string versionId, string tierId, int? offset = default(int?), int? limit = default(int?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            VersionId = versionId;

            TierId = tierId;

            Offset = offset;
            Limit = limit;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/versions/{versionId}/tiers/{tierId}/scores";

            List<string> queryParams = new List<string>();

            var offsetStringValue = Offset.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "offset", offsetStringValue);
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// ResetLeaderboardScoresRequest
    /// Reset Leaderboard Scores
    /// </summary>
    [Preserve]
    internal class ResetLeaderboardScoresRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for archive </summary>
        [Preserve]
        public bool? Archive { get; }
        string PathAndQueryParams;

        /// <summary>
        /// ResetLeaderboardScores Request Object.
        /// Reset Leaderboard Scores
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="archive">Whether or not to archive the current set of scores before resetting the leaderboard</param>
        [Preserve]
        public ResetLeaderboardScoresRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, bool? archive = default(bool?))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            Archive = archive;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}/scores";

            List<string> queryParams = new List<string>();

            var archiveStringValue = Archive.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "archive", archiveStringValue);
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateLeaderboardConfigRequest
    /// Update Leaderboard Config
    /// </summary>
    [Preserve]
    internal class UpdateLeaderboardConfigRequest : DefaultApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public System.Guid ProjectId { get; }
        /// <summary>Accessor for environmentId </summary>
        [Preserve]
        public System.Guid EnvironmentId { get; }
        /// <summary>Accessor for leaderboardId </summary>
        [Preserve]
        public string LeaderboardId { get; }
        /// <summary>Accessor for leaderboardConfig1 </summary>
        [Preserve]
        public Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardConfig1 LeaderboardConfig1 { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateLeaderboardConfig Request Object.
        /// Update Leaderboard Config
        /// </summary>
        /// <param name="projectId">ID of the project</param>
        /// <param name="environmentId">ID of the environment</param>
        /// <param name="leaderboardId">ID of the leaderboard</param>
        /// <param name="leaderboardConfig1">LeaderboardConfig1 param</param>
        [Preserve]
        public UpdateLeaderboardConfigRequest(System.Guid projectId, System.Guid environmentId, string leaderboardId, Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardConfig1 leaderboardConfig1 = default(Unity.Services.Leaderboards.Authoring.Client.Models.LeaderboardConfig1))
        {
            ProjectId = projectId;

            EnvironmentId = environmentId;

            LeaderboardId = leaderboardId;

            LeaderboardConfig1 = leaderboardConfig1;
            PathAndQueryParams = $"/api/leaderboards/v1/projects/{projectId}/environments/{environmentId}/leaderboards/{leaderboardId}";


        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(LeaderboardConfig1 != null)
            {
                return ConstructBody(LeaderboardConfig1);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PATCH";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }


            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
}
